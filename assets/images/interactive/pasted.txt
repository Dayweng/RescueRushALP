import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.Random;

public class App {

    // simple, procedural-style game state (no custom classes)
    static int playerX;
    static int playerY;
    static int speed   = 4;
    static int GameState = 0; // 0 = menu, 1 = level1
    static int nextScreen = 0;
    static Timer timer;
    static Timer timerInternal;

    public BufferedImage up1, up2, down1, down2, left1, left2, right1, right2;
    public BufferedImage grass, water0, waterup, waterdown, waterleft, waterright, waterupright, waterupleft, waterdownright, waterdownleft, road;
    public BufferedImage warningGreen;
    static String direction = "down";
    static int spriteCounter = 0;
    static int spriteNum = 1;
    static boolean isMoving = false;
    static int tileSize = 32;
    static int panelWidth = 1366;
    static int panelHeight = 768;
    static char[][] map;

    static int[][] warningPoints = new int[3][2];
    static Random random = new Random();


    // map games

    public BufferedImage imagemap1;


    //User ScreenSize
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    static int Screenwidth = 1366; //(int) screenSize.getWidth();
    static int Screenheight = 768; //(int) screenSize.getHeight();

    public static void main(String[] args) {
        System.out.println("Rescue Rush Game Starting...");
        System.out.println("Screen Width: " + Screenwidth + ", Screen Height: " + Screenheight);
        
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Rescue Rush");
            //frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
            frame.setSize(1366, 768);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setResizable(false);
            //frame.setUndecorated(true);

            // create an instance so we can use non-static (public void) methods
            final App app = new App();
            app.loadCharacterImages();
            app.loadTileImages();
            app.loadMap();
            spawnPlayerOnRoad();

            JPanel panel = new JPanel() {
                public void paintComponent(Graphics g) {
                    //Base game Logic (mskin game state sini)
                    super.paintComponent(g);
                    if (GameState == 0) {
                        app.OnBoarding(g, this);
                    } else if (GameState == 5) {
                        app.MenuScreen(g, this);
                    } else if (GameState == 1) {
                        app.drawTileMap(g, this);
                        app.drawCharacter(g, playerX, playerY, direction, spriteNum);
                    } else if (GameState == 100) {
                        app.selectLevelSScreen(g, this);
                    }
                }
            };

            panel.setFocusable(true);

            // keyboard: directly modify static state for smooth movement
            panel.addKeyListener(new KeyAdapter() {
                public void keyPressed(KeyEvent e) {
                    int k = e.getKeyCode();
                    if (k == KeyEvent.VK_W || k == KeyEvent.VK_UP) {
                        int newY = playerY - speed;
                        if (newY >= 0 && canMove(playerX, newY) && canMove(playerX + tileSize - 1, newY)) {
                            direction = "up";
                            playerY = newY;
                            isMoving = true;
                        }
                    }
                    if (k == KeyEvent.VK_S || k == KeyEvent.VK_DOWN) {
                        int newY = playerY + speed;
                        if (newY <= panelHeight - tileSize && canMove(playerX, newY) && canMove(playerX + tileSize - 1, newY)) {
                            direction = "down";
                            playerY = newY;
                            isMoving = true;
                        }
                    }
                    if (k == KeyEvent.VK_A || k == KeyEvent.VK_LEFT) {
                        int newX = playerX - speed;
                        if (newX >= 0 && canMove(newX, playerY) && canMove(newX, playerY + tileSize - 1)) {
                            direction = "left";
                            playerX = newX;
                            isMoving = true;
                        }
                    }
                    if (k == KeyEvent.VK_D || k == KeyEvent.VK_RIGHT) {
                        int newX = playerX + speed;
                        if (newX <= panelWidth - tileSize && canMove(newX, playerY) && canMove(newX, playerY + tileSize - 1)) {
                            direction = "right";
                            playerX = newX;
                            isMoving = true;
                        }
                    }
                    if (k == KeyEvent.VK_ESCAPE) frame.dispatchEvent(new WindowEvent(frame, WindowEvent.WINDOW_CLOSING));
                }
                public void keyReleased(KeyEvent e) {
                    int k = e.getKeyCode();
                    if (k == KeyEvent.VK_W || k == KeyEvent.VK_UP || k == KeyEvent.VK_S || k == KeyEvent.VK_DOWN ||
                        k == KeyEvent.VK_A || k == KeyEvent.VK_LEFT || k == KeyEvent.VK_D || k == KeyEvent.VK_RIGHT) {
                        isMoving = false;
                        spriteNum = 1; // reset to standing pose
                    }
                }
            });

            // mouse: check button coordinates on click
            panel.addMouseListener(new MouseAdapter() {
                public void mousePressed(MouseEvent e) {
                    int x = e.getX();
                    int y = e.getY();
                    if (x >= 540 && x <= 740 && y >= 600 && y <= 650) {
                        GameState = 100;
                    } else if (x >= 540 && x <= 740 && y >= 250 && y <= 300) {
                        GameState = 1;
                    } else if (x >= 540 && x <= 740 && y >= 320 && y <= 370) {
                        GameState = 2;
                    } else if (x >= 540 && x <= 740 && y >= 390 && y <= 440) {
                        GameState = 3;
                    }
                }
            });

            frame.add(panel);
            frame.setVisible(true);

            // ensure panel has focus so key events are delivered
            panel.requestFocusInWindow();

            // simple game loop timer (~60 FPS)
            timer = new Timer(16, ev -> {
                // could update game logic here
                updateSprite();
                panel.repaint();
            });
            timer.start();
        });
    }

    public void OnBoarding(Graphics g, Component c) {
        ImageIcon logo = new ImageIcon("assets/Logo/Rescue Rush Wide Logo.png");
        g.drawImage(logo.getImage(), Screenwidth/4, Screenheight/4, Screenwidth/2, Screenheight/3, c);
        
        timerInternal = new Timer(2000, ev -> {
                nextScreen = 1;
            });
        
        timerInternal.start();
        if (nextScreen == 1){
            timerInternal.stop();
            GameState = 5;
        }

    }
    
    public void MenuScreen(Graphics g, Component c) {
        ImageIcon mainMenuBG = new ImageIcon("assets/menu-background.gif");
        g.drawImage(mainMenuBG.getImage(), 0, 0, c.getWidth(), c.getHeight(), c);

        int buttonX = 540;
        int buttonY = 600;
        int buttonWidth = 200;
        int buttonHeight = 50;

        g.setColor(new Color(100, 150, 255));
        g.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

        g.setColor(Color.WHITE);
        g.setFont(new Font("Arial", Font.BOLD, 20));
        g.drawString("Start Game", buttonX + 50, buttonY + 35);
    }

    public void selectLevelSScreen(Graphics g, Component c) {
        ImageIcon mainMenuBG = new ImageIcon("assets/menu-background.gif");
        g.drawImage(mainMenuBG.getImage(), 0, 0, c.getWidth(), c.getHeight(), c);

        int buttonX = 540;
        int buttonY = 250;
        int buttonWidth = 170;
        int buttonHeight = 50;

        // button to start level 1
        g.setColor(new Color(100, 150, 255));
        g.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

        g.setColor(Color.WHITE);
        g.setFont(new Font("Arial", Font.BOLD, 20));
        g.drawString("LEVEL 1", buttonX + 50, buttonY + 35);

        //button to start level 2
        buttonY += 70;

        g.setColor(new Color(100, 150, 255));
        g.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

        g.setColor(Color.WHITE);
        g.setFont(new Font("Arial", Font.BOLD, 20));
        g.drawString("LEVEL 2", buttonX + 50, buttonY + 35);

        //button to start level 3

        buttonY += 70;
        g.setColor(new Color(100, 150, 255));
        g.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

        g.setColor(Color.WHITE);
        g.setFont(new Font("Arial", Font.BOLD, 20));
        g.drawString("LEVEL 3", buttonX + 50, buttonY + 35);

    }

    // CHARACTER FUNCTION

    public void loadCharacterImages() {
        try {
            up1 = javax.imageio.ImageIO.read(new java.io.File("assets/images/character/boy_up_1.png"));
            up2 = javax.imageio.ImageIO.read(new java.io.File("assets/images/character/boy_up_2.png"));
            down1 = javax.imageio.ImageIO.read(new java.io.File("assets/images/character/boy_down_1.png"));
            down2 = javax.imageio.ImageIO.read(new java.io.File("assets/images/character/boy_down_2.png"));
            left1 = javax.imageio.ImageIO.read(new java.io.File("assets/images/character/boy_left_1.png"));
            left2 = javax.imageio.ImageIO.read(new java.io.File("assets/images/character/boy_left_2.png"));
            right1 = javax.imageio.ImageIO.read(new java.io.File("assets/images/character/boy_right_1.png"));
            right2 = javax.imageio.ImageIO.read(new java.io.File("assets/images/character/boy_right_2.png"));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void drawCharacter(Graphics g, int x, int y, String dir, int num) {
        BufferedImage img = null;
        if (dir.equals("up")) {
            img = (num == 1) ? up1 : up2;
        } else if (dir.equals("down")) {
            img = (num == 1) ? down1 : down2;
        } else if (dir.equals("left")) {
            img = (num == 1) ? left1 : left2;
        } else if (dir.equals("right")) {
            img = (num == 1) ? right1 : right2;
        }
        if (img != null) {
            g.drawImage(img, x, y, 32, 32, null);
        }
    }

    public static void updateSprite() {
        if (isMoving) {
            spriteCounter++;
            if (spriteCounter > 10) {
                spriteNum = (spriteNum == 1) ? 2 : 1;
                spriteCounter = 0;
            }
        } else {
            spriteNum = 1;
        }
    }

    // MAP FUNCTIONS

    public void loadTileImages() {
        try {
            grass = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/grass01.png"));
            water0 = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/water01.png"));
            waterup = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/water08.png"));
            waterdown = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/water03.png"));
            waterleft = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/water06.png"));
            waterright = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/water05.png"));
            waterupright = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/water10.png"));
            waterupleft = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/water11.png"));
            waterdownright = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/water12.png"));
            waterdownleft = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/water13.png"));
            road = javax.imageio.ImageIO.read(new java.io.File("assets/images/tile/road00.png"));
            warningGreen = javax.imageio.ImageIO.read(new java.io.File("assets/images/interactive/warning-green.png"));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void drawTileMap(Graphics g, Component c) {
        try {
            java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.FileReader("assets/maps/level1.txt"));
            String line;
            int row = 0;
            while ((line = reader.readLine()) != null) {
                for (int col = 0; col < line.length(); col++) {
                    char tile = line.charAt(col);
                    if (tile == '0') {
                        g.drawImage(road, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                    if (tile == '1') {
                        g.drawImage(grass, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                    if (tile == '2') {
                        g.drawImage(water0, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                    if (tile == '3') {
                        g.drawImage(waterup, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                    if (tile == '4') {
                        g.drawImage(waterdown, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                    if (tile == '5') {  
                        g.drawImage(waterleft, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                    if (tile == '6') {  
                        g.drawImage(waterright, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                    if (tile == '7') {  
                        g.drawImage(waterupright, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                    if (tile == '8') {  
                        g.drawImage(waterupleft, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                    if (tile == '9') {  
                        g.drawImage(waterdownright, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                    if (tile == 'A') {  
                        g.drawImage(waterdownleft, col * tileSize, row * tileSize, tileSize, tileSize, c);
                    }
                }
                row++;
            }
            reader.close();
            for (int i = 0; i < 3; i++) {
                g.drawImage(warningGreen, warningPoints[i][0], warningPoints[i][1], tileSize, tileSize, c);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void loadMap() {
        try {
            java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.FileReader("assets/maps/level1.txt"));
            java.util.List<String> lines = new java.util.ArrayList<>();
            String line;
            while ((line = reader.readLine()) != null) {
                lines.add(line);
            }
            reader.close();
            int rows = lines.size();
            int cols = lines.get(0).length();
            map = new char[rows][cols];
            for (int r = 0; r < rows; r++) {
                for (int c = 0; c < cols; c++) {
                    map[r][c] = lines.get(r).charAt(c);
                }
            }
            generateWarningPoints();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static boolean canMove(int x, int y) {
        int left = x;
        int right = x + tileSize - 1;
        int top = y;
        int bottom = y + tileSize - 1;
        return isWalkable(left, top) && isWalkable(right, top) && isWalkable(left, bottom) && isWalkable(right, bottom);
    }

    private static boolean isWalkable(int x, int y) {
        int col = x / tileSize;
        int row = y / tileSize;
        if (col < 0 || col >= map[0].length || row < 0 || row >= map.length) {
            return false;
        }
        return map[row][col] == '0';
    }

    public void generateWarningPoints() {
        int count = 0;
        while (count < 3) {
            int col = random.nextInt(map[0].length);
            int row = random.nextInt(map.length);
            if (map[row][col] == '0') { // road
                warningPoints[count][0] = col * tileSize;
                warningPoints[count][1] = row * tileSize;
                count++;
            }
        }
    }

    static void spawnPlayerOnRoad() {
        for (int r = 0; r < map.length; r++) {
            for (int c = 0; c < map[0].length; c++) {
                if (map[r][c] == '0') {
                    playerX = c * tileSize;
                    playerY = r * tileSize;
                    return;
                }
            }
        }
    }

}

